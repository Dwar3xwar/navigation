<html>
<head>
    <title>Navigation Data</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="../css/prism.css">
    <link rel="stylesheet" href="../css/navigation.css">
</head>
<body>
    <div id="banner">
        <div>
            <a href="../index.html">Navigation</a>
            <a href="hello-world.html" class="selected">Docs</a>
            <a href="../download/index.html">Download</a>
            <a id="github" href="https://github.com/grahammendick/navigation">GitHub source</a>
        </div>
    </div>
    <div id="content">
        <div id="menu">
            <a href="hello-world.html">Hello World</a>
            <a href="thinking-in-navigation.html">Thinking in Navigation</a>
            <div class="separator"></div>
            <h2>THE ABC</h2>
            <a href="state-navigation.html">A. State Navigation</a>
            <a href="navigation-data.html" class="selected">B. Navigation Data</a>
            <a href="routes.html">C. Routes</a>
            <div class="separator"></div>
            <h2>FURTHER GUIDES</h2>
            <a href="breadcrumb-trail.html">Breadcrumb Trail</a>
            <a href="current-data.html">Current Data</a>
            <a href="html5-history.html">HTML5 History</a>
            <a href="navigation-lifecycle.html">Navigation Lifecycle</a>
            <div class="separator"></div>
            <a href="email-example.html">Email Example</a>
            <a href="reusable-components.html">Reusable Components</a>
        </div>
        <div id="article">
            <h1>Navigation Data</h1>
            <h2>Passing Data</h2>
            <p>
                When it comes to passing data between views, the Navigation router isn't like other routers. Other routers make you define your routes and parameters up front. The Navigation router thinks in terms of <code>States</code> and data so you don't need to think about routes and parameters until your application's working.
            </p>
            <p>
                You can use the <code>NavigationLink</code> component to build Hyperlinks that navigate between <code>States</code>. As well as a <code>stateKey prop</code> that holds the destination <code>State</code>, the <code>NavigationLink</code> component has a <code>navigationData prop</code> that holds the data to pass. You don't have to convert data to strings because it accepts numbers, booleans and dates and even arrays of such values. In an email application, for example, a Hyperlink that opens an email might pass along the email id together with a flag that indicates the thread's history should be initially collapsed.
            </p>
            <pre><code class="language-jsx">&lt;NavigationReact.NavigationLink 
  stateKey="mail"
  navigationData={{id: 12, expand: false}}
  stateNavigator={stateNavigator}>
  Open Mail
&lt;/NavigationReact.NavigationLink></code></pre>
            <p>
                For navigating without Hyperlinks, you can pass data in the second parameter of the <code>navigate</code> function on the <code>stateNavigator</code>.
            </p>
            <pre><code class="language-jsx">stateNavigator.navigate('mail', {id: 12, expand: false});</code></pre>
            <h2>Receiving Data</h2>
            <p>
                You'll recall that the Navigation router notifies you when a <code>State</code> becomes active by calling the function you assigned to the <code>navigated</code> property of that <code>State</code>. When it calls this function it passes in a parameter holding the navigation data. In the email example, when the mail <code>State</code> is active we use the <code>id</code> and <code>expand</code> data items passed in to set the respective <code>props</code> on our <code>Mail</code> component.
            </p>
            <pre><code class="language-jsx">stateNavigator.states.mail.navigated = function(data) {
  ReactDOM.render(
    &lt;Mail id={data.id} expand={data.expand} />,
    document.getElementById('app'));
};</code></pre>
            <p>
                You don't have to convert the data from strings because the Navigation router remembers their original types. Adding <code>prop type</code> validation to the <code>Mail</code> component, for example, wouldn't raise an exception.
            </p>
            <pre><code class="language-jsx">var Mail = React.createClass({
  propTypes: {
    id: React.propTypes.number,
    expand: React.propTypes.bool
  },
  /* ... */
});</code></pre>
            <h2>Setting Default Values</h2>
            <p>
                The Navigation router lets you define default navigation data values for each <code>State</code>. The data passed into a <code>State's navigated</code> function includes these default values for any item that you don't supply with a value when navigating. If we give the <code>expand</code> item in the email example a default value of false then we don't have to explicitly pass it in navigation data when the mail's opened.
            </p>
            <pre><code class="language-jsx">var stateNavigator = new Navigation.StateNavigator([
  {key: 'inbox', route: ''},
  {key: 'mail', defaults: {expand: false}},
  {key: 'compose'}
]);</code></pre>
            <h2>Setting Constraints</h2>
            <p>
                You can also define navigation data constraints in a function attached to the <code>validate</code> property of the <code>State</code>. This function receives the navigation data as a parameter and you return true only if the data meets your constraints. The Navigation router won't navigate to a <code>State</code> when the constraints aren't met. For example, we could create a constraint to ensure that the mail id is greater than zero.  
            </p>
            <pre><code class="language-jsx">stateNavigator.states.mail.validate = function(data) {
  return data.id > 0;
};</code></pre>
        </div>
    </div>
    <script type="text/javascript" src="../js/prism.js"></script>
</body>
</html>